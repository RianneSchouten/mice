---
title: "Generating imputations"
author: "Stef van Buuren"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{Generating imputations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
options(digits = 3, width = 65)
library("mice", quietly = TRUE)
```

## Inspecting the missing data

The number of the missing values can be counted and visualized as follows:

```{r}
library("mice")
md.pattern(nhanes)
```

There are 13 (out of 25) rows that are complete. There is one row for which only `bmi` is missing, and there are seven rows for which only `age` is known. The total number of missing values is equal to $(7\times 3)+(1\times 2)+(3\times 1)+(1\times 1) = 27$. Most missing values (10) occur in `chl`.

Another way to study the pattern involves calculating the number of observations per patterns for all pairs of variables. A pair of variables can have exactly four missingness patterns: both variables are observed (pattern `rr`), the first variable is observed and the second variable is missing (pattern `rm`), the first variable is missing and the second variable is observed (pattern `mr`), and both are missing (pattern `mm`). We can use the `md.pairs()` function to calculate the frequency in each pattern for all variable pairs as

```{r}
p <- md.pairs(nhanes)
p
```

Thus, for pair `(bmi,chl)` there are 13 completely observed pairs, 3 pairs for which `bmi` is observed but `hyp` not, 2 pairs for which `bmi` is missing but with `hyp` observed, and 7 pairs with both missing `bmi` and `hyp`. Note that these numbers add up to the total sample size.

Several `R` packages contain functions to plot the missing data pattern. Examples are `marginplot()` from `VIM`, bla bla.

## Imputation

Creating imputations can be done with a call to \code{mice()} as follows:

```{r cache = TRUE}
imp <- mice(nhanes, seed = 13212)
```
where the multiply imputed data set is stored in the object `imp` of class `mids`. Inspect what the result looks like

```{r}
print(imp)
```

Imputations are generated according to the default method, which is, for numerical data, predictive mean matching (`pmm`). The entries `imp$visitSequence` and `imp$predictorMatrix` are algorithmic options that are discussed in other vignettes. The default number of multiple imputations is equal to $m = 5$.


An important step in multiple imputation is to assess whether imputations are plausible. Imputations should be values that could have been obtained had they not been missing. Imputations should be close to the data. Data values that are clearly impossible (e.g., negative counts, pregnant fathers) should not occur in the imputed data. Imputations should respect relations between variables, and reflect the appropriate amount of uncertainty about their 'true' values.

Diagnostic checks on the imputed data provide a way to check the plausibility of the imputations. The imputations for `bmi` are stored as

```{r}
imp$imp$bmi
```

Each row corresponds to a missing entry in `bmi`. The columns contain the multiple imputations. 

The completed data set combines the observed and imputed values. The (first) completed data set can be obtained as
```{r}
complete(imp)
```

The `complete()` function extracts the five imputed data sets from the `imp` object. The missing entries in `nhanes` have now been filled by the values from the first (of five) imputation. The second completed data set can be obtained by `complete(imp, 2)`. For the observed data, it is identical to the first completed data set, but it may differ in the imputed data.

It is often useful to inspect the distributions of original and the imputed data. One way of doing this is to use the function `stripplot()`, an adapted version of the same function in the package `lattice`. The following code creates the stripplot. 

```{r fig.cap = "Stripplot of four variables in the original data and in the five imputed data sets. Points are slightly jittered. Observed data in blue, imputed data in red.", fig.width = 5, fig.height = 5}
library("lattice")
stripplot(imp, pch = 20, cex = 0.9)
```

The figure shows the distributions of the four variables as individual points. Blue points are observed, the red points are imputed. The panel for `age` contains blue points only because `age` is complete. Furthermore, note that the red points follow the blue points reasonably well, including the gaps in the distribution, e.g., for `chl`.

The scatterplot of `chl` and `bmi` for each imputed data set is created by
```{r fig.cap = "Scatterplot of cholesterol `chl` and body mass index `bmi` in the original data (panel 0), and five imputed data sets. Observed data in blue, imputed data in red.", fig.width = 5, fig.height = 4}
xyplot(imp, bmi ~ chl | .imp, pch = 20, cex = 1.0)
```

Imputations are plotted in red. The blue points are the same across different panels, but the red points vary. The red points have more or less the same shape as blue data, which indicates that they could have been plausible measurements if they had not been missing. The differences between the red points represents our uncertainty about the true (but unknown) values.

Under MCAR, univariate distributions of the observed and imputed data are expected to be identical. Under MAR, they can be different, both in location and spread, but their multivariate distribution is assumed to be identical. There are many other ways to look at the completed data, but we defer of a discussion of those to vignette "Checking".

## Analysis

Suppose that the complete-data analysis of interest is a linear regression of `chl` on `age` and `bmi`. For this purpose, we can use the function `with()`, a wrapper function that applies the complete-data model to each of the imputed data sets:

```{r}
fit <- with(imp, lm(chl ~ age + bmi))
class(fit)
```

The `fit` object has class `mira` and contains the results of five complete-data analyses. 

It is sometimes useful to inspect or process the model fitted to each imputed data set. The list of models are easily extracted from `fit` as `fit$analyses`. Thus, `length(fit$analyses)` is equal to the number of imputations. The summary of the model fitted to the first imputed data set is obtained as 

```{r}
summary(fit$analyses[[1]])
```

Note that this analysis treats the imputed values as real values, so the standard errors and the $P$-values are too low.


## Pooling

After fitting each of the models to the multiple imputed data, the estimates in each of the models need to be combined by Rubin's rules. This can be done as:

```{r}
est <- pool(fit)
summary(est)
```

After multiple imputation, we find a significant effect `bmi`. 

The column `fmi` contains the *fraction of missing information* [@rubin1987], and the column `lambda` is the proportion of the total variance that is attributable to the missing data ($\lambda=(B + B/m)/T$) [@vanbuuren2012]. 

The pooled results are subject to simulation error and therefore depend on the `seed` argument of the `mice()` function that controls the random seed. In order to minimize simulation error, we can use a higher number of imputations, for example `m = 50`. It is easy to do this as

```{r cache = TRUE}
imp50 <- mice(nhanes, m = 50, seed = 23109, print = FALSE)
fit <- with(imp50, lm(chl ~ age + bmi))
summary(pool(fit))
```

We find that actually both `age` and `chl` are significant effects. This is the result that can be reported. 


## Further reading

